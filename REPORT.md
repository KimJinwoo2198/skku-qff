# 파라미터화된 양자 회로(PQC) 실험 보고서

본 문서는 2-큐비트 PQC를 이용해 고전 논리 게이트를 학습한 일련의 실험 결과를 정리한다. 요구 사항 1~3을 순서대로 다루며, 비얽힘 실험은 `skku1.py`, 얽힘 실험은 `skku2.py`, 각도 인코딩 실험은 `skku3.py` 실행으로 재현할 수 있다.

---

## 1. 2-Qubit PQC 설계 및 학습

### 회로 구조 (요구 사항 1)
- 구현 파일: `pqc/model.py`
- 구성 요소:
  1. **기저 인코딩**: 입력 비트 `x = (x_0, x_1)`에 대해 각 큐비트에 Pauli-X를 적용해 `|x_0 x_1⟩` 상태를 만든다.
  2. **Data Re-uploading 층**: 블록 수 `L=2`로 고정하고, 각 블록에서 모든 큐비트에 대해 `RY(θ) → RZ(φ) → RY(λ)`를 수행한다. 동시에 입력 비트에 조건부로 추가 회전 `RY(α * x_0)` 및 `RY(β * x_1)`를 삽입해 피처 재업로드를 구현했다.
  3. **측정**: 첫 번째 큐비트에서 `⟨Z⟩` 기대값을 측정하고 확률로 변환한다.

이 회로는 얽힘 게이트를 사용하지 않으면서도 Figure 1의 층 구조(기저 인코딩 + 회전 게이트 블록 반복)를 그대로 따른다. 전체 파라미터 수는 `5 × 2 × L = 20`개로, 모든 게이트 학습에서 동일하게 공유된다.

### 최적화 및 데이터셋
- 데이터셋: `pqc/gates.py`에서 진리표를 `qnp.array` 입력, `float` 타깃으로 변환.
- 손실 함수: 평균제곱오차(MSE)
  \[
    \mathcal{L}(\theta) = \frac{1}{4} \sum_{x \in \{0,1\}^2} \left( p_\theta(1 \mid x) - y(x) \right)^2
  \]
  여기서 \(p_\theta(1 \mid x) = \frac{1 - \langle Z_0 \rangle_\theta(x)}{2}\).
- 옵티마이저: `qml.AdamOptimizer` (학습률 0.2, 최대 400 step). PennyLane의 자동미분을 사용해 매 스텝 파라미터를 갱신했다.

---

## 2. Qiskit 시각화 및 로지스틱 회귀 비교 (요구 사항 2)

### 회로 시각화
- 구현 파일: `pqc/report.py`
- `display_qiskit_report()`는 PennyLane에서 학습된 파라미터를 가져와 Qiskit `QuantumCircuit`으로 복원하고 `draw(output="text")`로 ASCII 다이어그램을 출력한다.
- `skku1.py` 실행 시 각 게이트 학습 직후 회로 도식이 나타난다.

### 로지스틱 회귀와의 구조적 대응
| PQC 요소 | 로지스틱 회귀 대응 | 설명 |
| --- | --- | --- |
| 기저 인코딩 \( |x_0 x_1⟩ \) | 입력 벡터 \(x\) | 입력 정보가 양자 상태의 진폭(또는 위상)에 직접 반영 |
| 파라미터화된 RY/RZ | 가중치 \(w\), 바이어스 \(b\) | 회전 각도는 연속 파라미터이며, 기대값에 선형/비선형 변환을 가함 |
| 블록 반복 (Data Re-uploading) | 다층 피처 맵/비선형 확장 | 입력 의존 회전이 반복되면서 고차 피처 공간을 탐색 |
| 측정 \(p_\theta(1 \mid x)\) | 시그모이드 \(\sigma(w^\top x + b)\) | 둘 다 확률 출력; 측정 노이즈 vs 결정적 계산 차이 존재 |

### 근본적인 차이
1. **모델 공간**: 로지스틱 회귀는 유클리드 공간에서의 선형 결합 + 시그모이드에 해당하지만, PQC 파라미터는 유니터리 제약을 받는 리만 다양체에 놓여 있으며, 주기성과 게이트 순서에 따라 비선형 간섭이 자연 발생한다.
2. **표현력**: PQC는 중첩·간섭으로 인해 힐베르트 공간 전체를 탐색하므로, 얽힘 없이도 주기적/고차 결정 경계를 표현할 수 있다. 로지스틱 회귀는 명시적 피처 확장을 하지 않으면 선형 경계에 제한된다.
3. **최적화/샘플링**: PQC는 기대값 추정을 위해 샷 노이즈를 감내해야 하며(본 실험은 `shots=None`으로 이상적 상황), 로지스틱 회귀는 닫힌 형태의 그라디언트를 사용한다.

---

## 3. 게이트별 학습 결과 및 수학적 분석 (요구 사항 3)

### 성능 요약
| 게이트 | 최종 손실 | 정확도 | 특징 |
| --- | --- | --- | --- |
| AND | 0.0214 | 100% | 낮은 양성 비율(1개만 1)에도 안정적 수렴 |
| OR | 0.0214 | 100% | AND와 유사한 손실 → 파라미터 공간 대칭성 반영 |
| NAND | 0.0214 | 100% | OR 결과의 보수 형태를 성공적으로 모사 |
| NOR | 0.0010 | 100% | 네 입력 중 1개만 1이라 손실 최소화 쉬움 |
| XOR | 0.0006 | 100% | 비선형 게이트도 얽힘 없는 구조로 학습 성공 |
| XNOR | 0.0007 | 100% | XOR의 보수 패턴(같은 입력일 때 1)을 안정적으로 재현 |

### 수학적 원인 분석

#### 3.1 선형 분리 가능한 게이트 (AND, OR, NAND, NOR)
- 해당 게이트들은 입력 공간에서 선형 결정 경계로 분리 가능하다. 예를 들어 AND는 \(x_0 + x_1 \ge 1.5\) 같은 단순 경계로 표현된다.
- PQC의 한 블록은 기저 인코딩 후 회전 게이트를 적용하므로,
  \[
    \langle Z_0 \rangle = \cos\big(f_\theta(x)\big)
  \]
  형태의 주기 함수가 된다. 여기서 \(f_\theta(x)\)는 입력과 파라미터의 선형 결합이지만, `cos` 조성을 통해 자연스러운 비선형성을 제공한다.
- 선형 분리 문제의 경우 `cos`가 단조 구간에서 작동하도록 파라미터를 조정하면 로지스틱 회귀와 거의 동일한 역할을 수행한다. 따라서 손실이 동일한 값으로 수렴하며(대칭), 파라미터도 서로 유사한 패턴을 보인다.

#### 3.2 비선형 게이트 (XOR)
- XOR은 단일 선형 경계로 분리할 수 없어, 로지스틱 회귀는 실패한다. 그러나 본 PQC는 **데이터 재업로드(Data Re-uploading)**를 통해 입력 비트가 여러 차례 회전에 재등장한다.
- 두 번째 블록에서 첫 번째 블록의 결과가 다시 RY/RZ에 흐르므로,
  \[
    \langle Z_0 \rangle = \cos\big(a_0 + a_1 x_0 + a_2 x_1 + a_3 x_0 x_1 + a_4 \sin(b_1 x_0 + b_2 x_1)\big)
  \]
  와 같이 고차 상호작용 항이 암묵적으로 생성된다. 특히 `x_0 x_1` 항이나 사인/코사인 곱 형태가 XOR의 패리티 구조를 포착해 확률 \(p_\theta(1 \mid x)\)가 0 ↔ 1 패턴을 완벽히 재현한다.
- 얽힘이 없음에도 가능한 이유는 **비선형 회전 + 입력 조건부 게이트**가 고차 피처 확장을 담당하기 때문이다. 이는 로지스틱 회귀에서 커널 기법을 도입한 것과 유사하지만, PQC는 양자 상태 진화 자체가 커널을 내장한다.

#### 3.3 손실 값의 차이
- OR/NAND/AND는 비슷한 손실(≈0.0214)에 머물며, NOR/XOR는 훨씬 낮다. 이는 타깃 확률 분포와 예측 확률의 차이 제곱을 평균할 때 **정답 레이블 분포**가 영향을 주는 탓이다.
  - AND/OR/NAND는 4개 샘플 중 2~3개에서 확률을 극단으로 밀어야 하므로 회전 주기적 제약 때문에 약간의 잔차가 남는다.
  - NOR/XOR는 극단 값이 분포 전체에 고르게 나타나서, 파라미터 한 세트가 모든 입력에서 거의 0 또는 1을 내도록 맞추기 쉽다.
- 수렴 허용 오차(`convergence_tol=1e-3`)보다 손실이 큰 경우에도 정확도가 100%인 이유는, MSE가 확률 오차를 계속 측정하기 때문이다. 예를 들어 AND 게이트에서 (1,1)의 확률이 0.854이지만 임계값 0.5를 넘기 때문에 분류 정확도는 완벽하다.

#### 3.4 의미 해석
- **모델 단순성 대비 표현력**: 얽힘 없이도 20개의 파라미터와 반복 회전만으로 2비트 논리 게이트 전체를 학습했다는 점은, 소규모 NISQ 디바이스에서도 특정 논리 연산을 데이터 기반으로 재현할 수 있음을 시사한다.
- **주기적 손실 지형**: 모든 게이트가 유사한 손실 궤적을 보인 것은 회전 각도가 \(2\pi\) 주기를 갖기 때문이며, 최적화 시 다수의 동등한 최소점을 가진다. 이로 인해 서로 다른 게이트가 유사한 파라미터 집합으로 수렴할 수 있고, 이는 대칭성 기반 일반화 가능성에 대한 힌트를 준다.
- **로지스틱 회귀 대비 장점**: XOR 학습 성공은 로지스틱 회귀가 가진 선형 결정 경계 한계를 PQC가 넘어설 수 있음을 보여준다. 따라서 고전 모델로는 어렵지만 힐베르트 공간에서 자연스럽게 표현되는 함수군을 PQC가 효율적으로 구현할 수 있음을 의미한다.

---

## 4. 얽힘 기반 PQC(tangle 모듈)

### 회로 구조
- 구현 파일: `pqc/tangle.py`
- 기존 비얽힘 PQC와 동일한 기저 인코딩 및 데이터 재업로드 블록을 사용하되, 각 블록 말미에 **양방향 얽힘 게이트** \(E = U_{\text{ent}}^{(0\rightarrow1)} U_{\text{ent}}^{(1\rightarrow0)}\)를 삽입했다.
- 기본 entangler는 CNOT이지만, 설정에서 `CZ`, `ISWAP`, `SWAP` 등으로 대체 가능하다. `mirror_entangler=True`로 제어하면 제어/타깃 순서를 뒤집은 게이트를 즉시 적용해 양방향 상호작용을 형성한다.
- 한 블록의 유니터리는
  \[
    U_{\text{block}} = \left(\bigotimes_{i} R_Y(\alpha_i x_0) R_Y(\beta_i x_1) R_Y(\theta_i) R_Z(\phi_i) R_Y(\lambda_i)\right) \cdot E
  \]
  으로 표현되며, 블록을 반복하면서 얽힘과 재업로드가 번갈아 등장한다.

### 학습 성능
| 게이트 | 최종 손실 | 정확도 | 개선 포인트 |
| --- | --- | --- | --- |
| AND | 0.000868 | 100% | 얽힘을 통해 (1,1) 샘플 확률을 0.996까지 끌어올려 잔차 감소 |
| OR | 0.000798 | 100% | 부울 합 구조가 얽힘으로 강화되어 오류가 한 자릿수 ‰ 수준 |
| NAND | 0.000944 | 100% | 보수 게이트도 동일 파이프라인으로 안정적 학습 |
| NOR | 0.000694 | 100% | 희소 양성 샘플(0,0)에서 확률 0.985까지 상승 |
| XOR | 0.000608 | 100% | 얽힘으로 패리티 구조를 양자얽힘 상태에서 직접 표현 |
| XNOR | 0.000932 | 100% | 동일 입력 조건을 양방향 CNOT으로 빠르게 포착 |

비얽힘 모델도 이미 정확도 100%였지만, 얽힘 추가 후 모든 게이트의 MSE가 한 자릿수 e-3 이하로 감소했다. 특히 AND/OR처럼 선형 분리 가능한 문제에서도 얽힘이 잔차를 크게 줄여, 동일 shots 수로 더 낮은 분산을 기대할 수 있다.

### 수학적 해석
- CNOT을 예로 들면, 제어 큐비트에 `RY`가 적용된 상태 \(|\psi_c\rangle = a|0\rangle + b|1\rangle\)와 타깃 상태 \(|\psi_t\rangle\)가 있을 때,
  \[
    \text{CNOT}(|\psi_c\rangle \otimes |\psi_t\rangle) = a|0\rangle \otimes |\psi_t\rangle + b|1\rangle \otimes X|\psi_t\rangle
  \]
  로 전개된다. 이 항에는 \(ab\)가 곱해져 있으며, 이는 곧 \(x_0 x_1\)과 유사한 **이차 상호작용 항**이다. mirror CNOT을 추가하면 두 큐비트 모두가 서로의 상태에 조건부로 영향을 주므로, \(x_0 x_1\), \(x_0(1-x_1)\) 등 다양한 조합이 자연스럽게 생성된다.
- 측정 기대값은
  \[
    \langle Z_0 \rangle = \sum_{x} |c_x|^2 (-1)^{x_0}
  \]
  형태인데, 얽힘 후 계수 \(c_x\)가 두 비트의 공동 분포를 반영하므로, 비얽힘 회로 대비 **상관관계 항**이 추가된다. 이는 커널 기법 관점에서 조건부 위상으로 고차 피처를 추가한 것과 같다.
- Data re-uploading과 얽힘을 번갈아 적용하면 \(U(\theta, x) = \prod_\ell U_\ell(\theta_\ell, x)\) 구조가 되며, Baker-Campbell-Hausdorff 전개 시 고차 항이 누적되어 even/odd 패리티 같은 함수를 짧은 깊이에서 표현할 수 있다.

### 의미
- 얽힘은 비선형 상호작용을 명시적으로 생성해, 샷 노이즈 환경에서도 높은 마진을 확보한다. 실험 결과에서 최소 확률이 0.96 이상으로 밀려, 측정 횟수를 줄여도 로버스트한 분류가 가능하다.
- `EntangledPQCConfig`로 entangler 종류·순서를 손쉽게 바꿀 수 있어, 하드웨어 제약(예: CZ만 지원)에도 대응 가능하다.
- `skku2.py`는 얽힘 회로 전용 실험 엔트리 포인트로, 비얽힘 결과(`skku1.py`)와 분리된 로그를 제공한다.

---

## 5. 각도 인코딩 PQC(angle 모듈)

### 회로 구조
- 구현 파일: `pqc/angle/` 하위 모듈
- Figure 2 요구에 맞춰 **Angle encoding → Ansatz layer → Single qubit measurement** 순서를 유지한다.
  1. **Angle encoding**: `AngleEncodedTwoQubitPQC._angle_encoding()`에서 각 입력 비트 \(x_i\)를 `angle_scale·x_i + angle_bias` 각도로 변환해 지정 축(`angle_axis`, 기본 `RY`) 회전을 적용한다. 이는 계산 기저 대신 회전 각도에 정보를 실어 보내는 방식이다.
  2. **Ansatz layer**: 입력과 무관한 순수 파라미터 회전 `RY → RZ → RY → RX → RZ`를 각 큐비트에 적용한 뒤, 두 번의 \(CRX(\pi/2)\)로 약한 얽힘을 부여한다. 이는 Figure 2의 넓은 Ansatz 블록 내부에 해당한다.
  3. **단일 큐비트 측정**: 기존과 동일하게 첫 번째 큐비트의 \( \langle Z \rangle \)을 측정하여 확률을 얻는다.

### 학습 성능
| 게이트 | 최종 손실 | 정확도 | 메모 |
| --- | --- | --- | --- |
| AND | 0.0833 | 100% | 입력이 각도로 분포되면서 (1,1)만 고각으로 회전해 분류 |
| OR | 0.0835 | 100% | 기저 인코딩 대비 P(1) 마진이 줄었지만 정확도 유지 |
| NAND | 0.0834 | 100% | OR 학습 파라미터를 보수 형태로 재사용 |
| NOR | 0.0834 | 100% | (0,0) 샘플이 1.0 확률에 근접, 나머진 0.33 수준 |
| XOR | 0.0008 | 100% | Angle encoding + CRX 조합이 패리티 구조를 정확히 재현 |
| XNOR | 0.0009 | 100% | 동일 입력일 때 회전 각도가 동기화돼 높은 신뢰도로 1을 출력 |

MSE 값은 비얽힘/얽힘 회로보다 높지만, 이는 Angle encoding이 입력을 단순 회전으로만 주입해 두 상태 간 마진이 상대적으로 작기 때문이다. 그럼에도 CRX로 약한 얽힘을 삽입했기 때문에 XOR처럼 선형 분리가 불가능한 함수도 정확히 모델링한다.

### 수학적 해석
- Angle encoding은 \(x_i \mapsto \theta_i = s x_i + b\) 변환 후 \(R_\alpha(\theta_i)\)를 적용한다. 두 입력이 0 또는 1이므로, 실제 회전 각도는 \(\{b, s + b\}\) 두 값으로 제한된다. 따라서 회로는 “저차 피처 맵”을 원형 공간에서 구현한다.
- Ansatz는 입력과 독립적인 파라미터만 포함하므로, 전체 유니터리는
  \[
    U(\theta, x) = \left(\prod_{\ell=1}^{L} U_{\text{var}}(\theta_\ell) \cdot \text{CRX}_{01}\left(\frac{\pi}{2}\right)\cdot \text{CRX}_{10}\left(\frac{\pi}{2}\right)\right) \cdot U_{\text{enc}}(x)
  \]
  형태가 된다. 여기서 \(U_{\text{enc}}\)가 모든 데이터 의존성을 맡고, \(U_{\text{var}}\)가 결정 경계를 회전·뒤틀어 준다.
- XOR의 경우 두 입력 중 하나만 1일 때 한 큐비트만 \(\pi\) 근처로 회전하고, CRX가 다른 큐비트에 위상 변조를 전달해 중첩 간섭을 만든다. 이로써 패리티 조건을 자연스럽게 구현한다.
- `skku3.py`를 실행하면 Angle encoding 회로만 별도로 학습 및 시각화되어, Figure 2 구조와의 대응을 확인할 수 있다.

---

## 결론
1. 요구 사항 1: 얽힘 없이도 Figure 1 구조를 따르는 2-Qubit PQC를 구현하고, 진리표 기반 학습으로 모든 고전 게이트를 재현했다.
2. 요구 사항 2: Qiskit 회로 시각화와 로지스틱 회귀와의 구조적 대응/차이를 분석하는 모듈을 통합해 `skku1.py` 실행만으로 결과를 확인할 수 있다.
3. 요구 사항 3: 모든 게이트가 100% 정확도로 학습되었으며, 손실 값과 수렴 양상을 수학적으로 해석해 PQC의 표현력 및 로지스틱 회귀 대비 장단점을 정리했다.
4. 얽힘 확장: `pqc.tangle`을 통해 얽힘 게이트가 포함된 2-Qubit PQC를 구현·학습하고, 비얽힘 대비 손실 감소·상호작용 항 증폭 효과를 정량적으로 제시했다.
5. 각도 인코딩 확장: `pqc.angle`은 데이터 주입 방식을 기저 인코딩에서 회전 기반으로 바꿔 Figure 2 요구를 충족하며, `skku3.py`로 별도 실험을 수행할 수 있다.

이 문서는 추후 보고서나 발표 자료의 근간으로 사용할 수 있으며, 추가 실험(샷 노이즈 주입, 블록 수 증가, 얽힘/각도 인코딩 변형 등)을 위한 기준점 역할을 한다.

